{"remainingRequest":"/Users/johnchan/Documents/github/z-progress-loading/node_modules/vue-loader/lib/index.js??vue-loader-options!/Users/johnchan/Documents/github/z-progress-loading/src/index.vue?vue&type=style&index=0&lang=css&","dependencies":[{"path":"/Users/johnchan/Documents/github/z-progress-loading/src/index.vue","mtime":1584525048422},{"path":"/Users/johnchan/Documents/github/z-progress-loading/node_modules/css-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/johnchan/Documents/github/z-progress-loading/node_modules/vue-loader/lib/loaders/stylePostLoader.js","mtime":499162500000},{"path":"/Users/johnchan/Documents/github/z-progress-loading/node_modules/postcss-loader/src/index.js","mtime":499162500000},{"path":"/Users/johnchan/Documents/github/z-progress-loading/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/johnchan/Documents/github/z-progress-loading/node_modules/vue-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:CgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKI3otcHJvZ3Jlc3MtbG9hZGluZyB7CiAgd2lkdGg6IDEwMCU7CiAgaGVpZ2h0OiAxMDAlOwogIHBhZGRpbmc6IDAgOHB4OwogIGZsZXg6IDE7CiAgZGlzcGxheTogZmxleDsKICBhbGlnbi1pdGVtczogY2VudGVyOwp9CiN6LXByb2dyZXNzLWxvYWRpbmctY2FudmFzIHsKICBmbGV4OiAxOwp9Cg=="},{"version":3,"sources":["index.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA2KA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.vue","sourceRoot":"src","sourcesContent":["<template>\n  <div id=\"z-progress-loading\">\n    <canvas id=\"z-progress-loading-canvas\" :width=\"width\" :height=\"height\">\n      <i>Not supported.</i>\n    </canvas>\n  </div>\n</template>\n\n<script>\nconst isNoValue = (value) => {\n  return value === void 0 || value === null || value === '';\n};\n\nexport default {\n  name: 'z-progress-loading',\n  props: ['progress', 'start', 'config'],\n  watch: {\n    start(value) {\n      if (value) {\n        this.startLoading();\n      } else {\n        this.stopLoading();\n      }\n    },\n    config: {\n      deep: true,\n      handler() {\n        this.init();\n      },\n    },\n  },\n  data() {\n    return {\n      width: 0,\n      height: 0,\n      elemWidth: 4,\n      elemMinWidth: 2,\n      elemMaxWidth: 8,\n      elemMinHeight: 4,\n      elemMaxHeight: 24,\n      elemDeltaHeight: 3,\n      spacing: 5,\n      bgColor: 'blue',\n      foreColor: 'cyan',\n      step: 1,\n      rects: [],\n      rectCount: 0,\n      raf: null,\n    };\n  },\n  mounted() {\n    this.init();\n    setTimeout(() => {\n      this.draw();\n    }, 0);\n  },\n  methods: {\n    init() {\n      const container = document.getElementById('z-progress-loading');\n      const { width, height } = container.getBoundingClientRect();\n      this.width = width - (8 * 2);\n      this.spacing = Math.floor(this.width * 0.035);\n      this.height = height;\n      this.elemWidth = Math.floor(this.width * 0.02);\n      if (this.elemWidth < this.elemMinWidth) {\n        this.elemWidth = this.elemMinWidth;\n      }\n      if (this.elemWidth > this.elemMaxWidth) {\n        this.elemWidth = this.elemMaxWidth;\n      }\n      this.elemMinHeight = this.elemWidth;\n      this.elemMaxHeight = Math.floor(this.height * 0.75);\n      this.elemDeltaHeight = Math.floor((this.elemMaxHeight - this.elemMinHeight) / 6);\n      // --start-- 个性化配置\n      const config = this.config || {};\n      this.elemWidth = Number(config.elemWidth) || this.elemWidth;\n      this.elemMinHeight = Number(config.elemMinHeight) || this.elemMinHeight;\n      this.elemMaxHeight = Number(config.elemMaxHeight) || this.elemMaxHeight;\n      console.log(config.elemDeltaHeight, typeof config.elemDeltaHeight);\n      if (!isNoValue(config.elemDeltaHeight)) {\n        const elemDeltaHeight = Number(config.elemDeltaHeight);\n        this.elemDeltaHeight = !isNaN(elemDeltaHeight) ? elemDeltaHeight : this.elemDeltaHeight;\n      }\n      if (!isNoValue(config.spacing)) {\n        const spacing = Number(config.spacing);\n        this.spacing = !isNaN(spacing) ? spacing : this.spacing;\n      }\n      this.bgColor = config.bgColor || this.bgColor;\n      this.foreColor = config.foreColor || this.foreColor;\n      this.step = Number(config.step) || this.step;\n      // --end--\n      this.rects = [];\n      this.rectCount = Math.floor(\n        (this.width + this.spacing) / (this.elemWidth + this.spacing)\n      );\n      let curHeight = this.elemMinHeight;\n      let delta = -this.elemDeltaHeight;\n      for (let i = 0; i < this.rectCount; i += 1) {\n        const x = i * (this.elemWidth + this.spacing);\n        const y = this.height / 2 - curHeight / 2;\n        const height = curHeight;\n        if (\n          curHeight + delta < this.elemMaxHeight &&\n          curHeight + delta > this.elemMinHeight\n        ) {\n          curHeight += delta;\n        } else {\n          delta = -delta;\n          curHeight += delta;\n        }\n        const fillStyle =\n          i / this.rectCount < this.progress / 100\n            ? this.foreColor\n            : this.bgColor;\n        this.rects.push({\n          x,\n          y,\n          width: this.elemWidth,\n          height,\n          fillStyle,\n          dir: delta,\n        });\n      }\n    },\n    updateRects() {\n      this.rects = this.rects.map((rect, index) => {\n        let { x, y, width, height, fillStyle, dir } = rect;\n        let delta = dir > 0 ? this.step : -this.step;\n        if (\n          height + delta < this.elemMaxHeight &&\n          height + delta > this.elemMinHeight\n        ) {\n          height += delta;\n        } else {\n          delta = -delta;\n          height += delta;\n        }\n        y = this.height / 2 - height / 2;\n        fillStyle =\n          index / this.rectCount < this.progress / 100\n            ? this.foreColor\n            : this.bgColor;\n        return { x, y, width, height, fillStyle, dir: delta };\n      });\n    },\n    draw() {\n      const ref = document.getElementById('z-progress-loading-canvas');\n      const ctx = ref.getContext('2d');\n      ctx.clearRect(0, 0, this.width, this.height);\n      this.rects.forEach(rect => {\n        const { x, y, width, height, fillStyle } = rect;\n        ctx.fillStyle = fillStyle;\n        ctx.fillRect(x, y, width, height);\n      });\n    },\n    startLoading() {\n      this.updateRects();\n      this.draw();\n      this.raf = requestAnimationFrame(this.startLoading.bind(this));\n    },\n    stopLoading() {\n      if (this.raf) {\n        cancelAnimationFrame(this.raf);\n        this.raf = null;\n      }\n    },\n  },\n};\n</script>\n\n<style>\n#z-progress-loading {\n  width: 100%;\n  height: 100%;\n  padding: 0 8px;\n  flex: 1;\n  display: flex;\n  align-items: center;\n}\n#z-progress-loading-canvas {\n  flex: 1;\n}\n</style>\n"]}]}